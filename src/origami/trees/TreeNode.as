/** * Copyright 2004 - 2010 Northwestern University and Jonathan A. Smith * * <p>Licensed under the Educational Community License, Version 2.0 (the * "License"); you may not use this file except in compliance with the * License. You may obtain a copy of the License at</p> * * http://www.osedu.org/licenses/ECL-2.0 * * <p>Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an "AS IS" * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express * or implied. See the License for the specific language governing * permissions and limitations under the License.</p> */package origami.trees{	/**	 * Abstract class of nodes in a tree.	 *	 * @author Jonathan A. Smith	 */	public class TreeNode	{	    /**		 * Constructs a TreeNode.		 */		function TreeNode()		{		}		// **** Parents and Children	    /**		 * Returns the parent node (or null if none).		 *		 * @return null (no parent node)		 */		public function get parent(): InternalNode		{			return null;		}	    /**		 * Returns an array of children. (Always an empty array).		 *		 * @return An empty array (no children)		 */		public function get children(): Array		{			return [];		}	    /**		 * Returns true only if this node has children.		 *		 * @return False (this node has no children)		 */		public function hasChildren(): Boolean		{			return false;		}	    /**		 * Returns true only if this is a root node.		 *		 * @return False (not a root)		 */		public function isRoot(): Boolean		{			return false;		}	    /**		 * Returns the root node.		 *		 * @return The root of the tree containing this node		 */		public function getRoot(): TreeNode		{			var examine: TreeNode = this;			while (!examine.isRoot())				examine = examine.parent;			return examine;		}		// **** Add and Remove Children	    /**		 * Determines if a node can be a child of this node. (Never)		 *		 * @param child potential child node		 * @return False (this node cannot have children)		 */		public function canAccept(child: TreeNode): Boolean		{			return false;		}	    /**		 * Called when this node is added to another.		 *		 * @param parent new parent node		 */		internal function addedTo(parent: InternalNode): void		{			// Intentionally empty		}	    /**		 * Called when this node is removed from another.		 *		 * @param parent former parent node		 */		public function removedFrom(parent: InternalNode): void		{			// Intentionally empty		}	    /**		 * Removes a node from its parent.		 */		public function remove(): void		{			parent.removeChild(this);		}		// **** Node Indexes	    /**		 * Returns The index of this node in its parent or -1 if no parent.		 *		 * @return The index of this node in its parent		 */		public function getIndex(): Number		{			if (parent == null) return -1;			var index: Number = parent.indexOfChild(this);	        return index;		}		// **** Broadcasting	    /* *	     * Broadcasts an event to all observers and all observers of each ancestor node.	     *	     * @param selector  selector name (usually a method name)	     * @param arguments array of arguments to pass with the notification		 * /	    public function broadcastWithArguments(selector: String, broadcast_arguments: Array): void	    {	        super.broadcastWithArguments(selector, broadcast_arguments);	        if (parent != null)	            parent.broadcastWithArguments(selector, broadcast_arguments);	    }	    */		// **** Pre-Order Traversal	    /**		 * Returns the next node in an pre-order traversal of the tree or null		 * if not found.		 *		 * @return Next node in pre-order traversal of the tree		 */		public function next(): TreeNode		{			// If this node has children, return first child			if (hasChildren())				return children[0];			// Look for next sibling of some ancestor			var node: TreeNode = this;			var ancestor: TreeNode = parent;			while (ancestor != null)			{				var after: TreeNode = ancestor.childAfter(node);				if (after != null)					return after;				node = ancestor;				ancestor = ancestor.parent;			}			// Finished traversing tree			return null;		}	    /**		 * Returns the previous node in an pre-order traversal of the tree or null		 * if not found.		 *		 * @return Previous node in pre-order traversal of the tree		 */		public function previous(): TreeNode		{			// Look for last sibling of parent			if (parent != null)			{				var before: TreeNode = parent.childBefore(this);				if (before != null)					return before.lastDescendant();			}			// None found, return parent			return parent;		}	    /**		 * Returns the first child after a specified sibling. Returns null if none.		 *		 * @param sibling sibling node to start search		 * @return Next node after sibling or null if none		 */		private function childAfter(sibling: TreeNode): InternalNode		{			// Look for sibling, then return next node			var children: Array = this.children;			for (var index: Number = 0; index < children.length; index++)			{				var child: TreeNode = children[index];				if (child == sibling)				{					if (index == (children.length - 1))						return null;					return children[index + 1];				}			}			// No child found after specified sibling			return null;		}	    /**		 * Returns the child before a specified sibling or null if none.		 *		 * @param sibling sibling node to start search		 * @return Node before sibling or null if none		 */	    private function childBefore(sibling: TreeNode): TreeNode		{			var prior: TreeNode = null;			// Look for sibling, then return prior node			var children: Array = this.children;			for (var index: Number = 0; index < children.length; index++)			{				var child: TreeNode = children[index];				if (child == sibling) return prior;				prior = child;			}			// No child			return null;		}	    /**		 * Returns the last descendant of this node. (That is the last		 * child of the last child etc.) If no children, returns this.		 */	    private function lastDescendant(): TreeNode		{			// If no children, return this			if (!hasChildren())				return this;			// Find last child of this node			var childList: Array = this.children;			var childCount: Number = childList.length;			var lastChild: TreeNode = childList[childCount - 1];			// Find last descendant of last child			var descendant: TreeNode = lastChild.lastDescendant();			if (descendant != null)				return descendant;			// If no further descendants, return last child			return lastChild;		}		// **** Descendants and Ancestors	    /**		 * Returns true only if one node is an ancestor of another.		 *		 * @param descendent possible descendent		 * @return True only if descendent is a descendent		 */		public function isAncestorOf(descendent: InternalNode): Boolean		{			return false;		}	    /**		 * Returns an array of ancestors from this node up to (not including)		 * a specified top node.		 *		 * @param stop node to end search		 * @return Empty array (no ancestors)		 */		public function ancestorsBelow(stop: InternalNode): Array		{			return [];		}	    /**		 * Returns an array of ancestors from this node up to the root.		 *		 * @return Empty array (no ancestors)		 */		public function ancestors(): Array		{			return [];		}	    /**		 * Returns an array of descendants of a specified node. The nodes in		 * the returned list are in post-order, that is leaf nodes before		 * parents.		 *		 * @return Empty array (no descendants)		 */		public function descendents(): Array		{			return [];		}		// **** String Representation	    /**		 * Returns a string representation of this object.		 *		 * @return An XML string representation of this node		 */		public function toString(): String		{			try			{				return "";// FIXME Translator.default_translator.convertToString(this);			}			catch (except: Error)			{			}			return "** Unknown";		}	}}